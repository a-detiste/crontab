Subject: Fix crontab file parsing
Author: Christian Kastner <debian@kvr.at>
Last-Update: 2010-04-14

The crontab parsing code contains a test condition that can never be reached.

Acked-by: Christian Kastner <debian@kvr.at>
Index: patched/user.c
===================================================================
--- patched.orig/user.c	2010-05-06 18:18:15.861436066 +0200
+++ patched/user.c	2010-05-06 18:18:25.803561007 +0200
@@ -75,11 +75,20 @@
 	/*
 	 * load the crontab
 	 */
-	while ((status = load_env(envstr, file)) >= OK) {
+	do {
+		status = load_env(envstr, file);
 		switch (status) {
 		case ERR:
-			free_user(u);
-			u = NULL;
+			/* If envstr has no content, we reached a proper EOF
+ 			 * and we can return to continue regular processing.
+			 *
+ 			 * If it does have content, we reached EOF without a
+ 			 * newline, so we bail out
+			 */
+			if (envstr[0] != '\0') {
+				free_user(u);
+				u = NULL;
+			}
 			goto done;
 		case FALSE:
 			e = load_entry(file, NULL, pw, envp);
@@ -92,7 +101,7 @@
 			envp = env_set(envp, envstr);
 			break;
 		}
-	}
+	} while (status >= OK);
 
  done:
 	env_free(envp);
Index: patched/entry.c
===================================================================
--- patched.orig/entry.c	2010-05-06 18:18:15.855435677 +0200
+++ patched/entry.c	2010-05-06 18:18:25.803561007 +0200
@@ -277,6 +277,10 @@
 	ch = get_string(cmd, MAX_COMMAND, file, "\n");
 
 	/* a file without a \n before the EOF is rude, so we'll complain...
+
+	   CK 2010-04-14: this code will never be reached. All calls to
+	   load_entry are proceeded by calls to load_env, which aborts on EOF, and
+       where load_env fails, the code bails out.
 	 */
 	if (ch == EOF) {
 		ecode = e_cmd;
