Subject: Correct memory management issues
Last-Update: 2010-04-11

Three kinds of fixes:
  1) Do not just assume that malloc() et al. return successfully
  2) Don't forget to free memory 
  3) Function implicitly relying on allocation have to test for successful
     return, too. These are usually env_init(), etc. They are included here
     because of the close way they are all tied together.

Acked-by: Christian Kastner <debian@kvr.at>
Index: patched/compat.c
===================================================================
--- patched.orig/compat.c	2010-05-06 18:18:24.437560974 +0200
+++ patched/compat.c	2010-05-06 18:18:27.645727100 +0200
@@ -53,7 +53,10 @@
 {
 	char	*temp;
 
-	temp = malloc(strlen(str) + 1);
+	if ((temp = malloc(strlen(str) + 1)) == NULL) {
+		errno = ENOMEM;
+		return NULL;
+	}
 	(void) strcpy(temp, str);
 	return temp;
 }
Index: patched/env.c
===================================================================
--- patched.orig/env.c	2010-05-06 18:18:24.458435579 +0200
+++ patched/env.c	2010-05-06 18:18:27.645727100 +0200
@@ -28,7 +28,8 @@
 {
 	register char	**p = (char **) malloc(sizeof(char **));
 
-	p[0] = NULL;
+	if (p)
+		p[0] = NULL;
 	return (p);
 }
 
@@ -58,8 +59,18 @@
 	for (count = 0;  envp[count] != NULL;  count++)
 		;
 	p = (char **) malloc((count+1) * sizeof(char *));  /* 1 for the NULL */
+	if (p == NULL) {
+		errno = ENOMEM;
+		return NULL;
+	}
 	for (i = 0;  i < count;  i++)
-		p[i] = strdup(envp[i]);
+		if ((p[i] = strdup(envp[i])) == NULL) {
+			while (--i >= 0)
+				(void) free(p[i]);
+			free(p);
+			errno = ENOMEM;
+			return NULL;
+		}
 	p[count] = NULL;
 	return (p);
 }
@@ -90,7 +101,11 @@
 		 * save our new one there, and return the existing array.
 		 */
 		free(envp[found]);
-		envp[found] = strdup(envstr);
+		if ((envp[found] = strdup(envstr)) == NULL) {
+			envp[found] = "";
+			errno = ENOMEM;
+			return NULL;
+		}
 		return (envp);
 	}
 
@@ -101,8 +116,15 @@
 	 */
 	p = (char **) realloc((void *) envp,
 			      (unsigned) ((count+1) * sizeof(char **)));
+	if (p == NULL) 	{
+		errno = ENOMEM;
+		return NULL;
+	}
 	p[count] = p[count-1];
-	p[count-1] = strdup(envstr);
+	if ((p[count-1] = strdup(envstr)) == NULL) {
+		errno = ENOMEM;
+		return NULL;
+	}
 	return (p);
 }
 
Index: patched/job.c
===================================================================
--- patched.orig/job.c	2010-05-06 18:18:15.622435978 +0200
+++ patched/job.c	2010-05-06 18:18:27.645727100 +0200
@@ -45,7 +45,8 @@
 		if (j->e == e && j->u == u) { return; }
 
 	/* build a job queue element */
-	j = (job*)malloc(sizeof(job));
+	if ((j = (job*)malloc(sizeof(job))) == NULL)
+		return;
 	j->next = (job*) NULL;
 	j->e = e;
 	j->u = u;
Index: patched/misc.c
===================================================================
--- patched.orig/misc.c	2010-05-06 18:18:24.458435579 +0200
+++ patched/misc.c	2010-05-06 18:18:27.646435759 +0200
@@ -479,7 +479,12 @@
 		     + strlen(event)
 		     + strlen(detail)
 		     + MAX_TEMPSTR);
-
+	if (msg == NULL) {
+	    /* damn, out of mem and we did not test that before... */
+	    fprintf(stderr, "%s: Run OUT OF MEMORY while %s\n",
+		    ProgramName, __FUNCTION__);
+	    return;
+	}
 	if (LogFD < OK) {
 		LogFD = open(LOG_FILE, O_WRONLY|O_APPEND|O_CREAT, 0600);
 		if (LogFD < OK) {
@@ -622,7 +627,8 @@
 {
 	register char *dst = malloc(len*4 + 1);
 
-	mkprint(dst, src, len);
+	if (dst)
+		mkprint(dst, src, len);
 
 	return dst;
 }
Index: patched/user.c
===================================================================
--- patched.orig/user.c	2010-05-06 18:18:25.803561007 +0200
+++ patched/user.c	2010-05-06 18:18:27.646435759 +0200
@@ -52,7 +52,7 @@
 	user	*u;
 	entry	*e;
 	int	status;
-	char	**envp;
+	char	**envp = NULL, **tenvp;
 
 	if (!(file = fdopen(crontab_fd, "r"))) {
 		perror("fdopen on crontab_fd in load_user");
@@ -63,14 +63,25 @@
 
 	/* file is open.  build user entry, then read the crontab file.
 	 */
-	u = (user *) malloc(sizeof(user));
-	u->name = strdup(name);
+	if ((u = (user *) malloc(sizeof(user))) == NULL) {
+		errno = ENOMEM;
+		return NULL;
+	}
+	if ((u->name = strdup(name)) == NULL) {
+		free(u);
+		errno = ENOMEM;
+		return NULL;
+	}
 	u->crontab = NULL;
 
 	/* 
 	 * init environment.  this will be copied/augmented for each entry.
 	 */
-	envp = env_init();
+	if ((envp = env_init()) == NULL) {
+		free(u->name);
+		free(u);
+		return NULL;
+	}
 
 	/*
 	 * load the crontab
@@ -98,7 +109,13 @@
 			}
 			break;
 		case TRUE:
-			envp = env_set(envp, envstr);
+			if ((tenvp = env_set(envp, envstr))) {
+				envp = tenvp;
+			} else {
+				free_user(u);
+				u = NULL;
+				goto done;
+			}
 			break;
 		}
 	} while (status >= OK);
Index: patched/entry.c
===================================================================
--- patched.orig/entry.c	2010-05-06 18:18:27.017560712 +0200
+++ patched/entry.c	2010-05-06 18:18:27.646435759 +0200
@@ -91,6 +91,7 @@
 	int	ch;
 	char	cmd[MAX_COMMAND];
 	char	envstr[MAX_ENVSTR];
+	char	**tenvp;
 
 	Debug(DPARS, ("load_entry()...about to eat comments\n"))
 
@@ -250,24 +251,52 @@
 	/* copy and fix up environment.  some variables are just defaults and
 	 * others are overrides.
 	 */
-	e->envp = env_copy(envp);
+	if ((e->envp = env_copy(envp)) == NULL) {
+		ecode = e_none;
+		goto eof;
+	}
 	if (!env_get("SHELL", e->envp)) {
 		sprintf(envstr, "SHELL=%s", _PATH_BSHELL);
-		e->envp = env_set(e->envp, envstr);
+		if ((tenvp = env_set(e->envp, envstr))) {
+			e->envp = tenvp;
+		} else {
+			ecode = e_none;
+			goto eof;
+		}
 	}
 	if (!env_get("HOME", e->envp)) {
 		sprintf(envstr, "HOME=%s", pw->pw_dir);
-		e->envp = env_set(e->envp, envstr);
+		if ((tenvp = env_set(e->envp, envstr))) {
+			e->envp = tenvp;
+		} else {
+			ecode = e_none;
+			goto eof;
+		}
 	}
 	if (!env_get("PATH", e->envp)) {
 		sprintf(envstr, "PATH=%s", _PATH_DEFPATH);
-		e->envp = env_set(e->envp, envstr);
+		if ((tenvp = env_set(e->envp, envstr))) {
+			e->envp = tenvp;
+		} else {
+			ecode = e_none;
+			goto eof;
+		}
+	}
+	snprintf(envstr, MAX_ENVSTR, "%s=%s", "LOGNAME", pw->pw_name);
+	if ((tenvp = env_set(e->envp, envstr))) {
+		e->envp = tenvp;
+	} else {
+		ecode = e_none;
+		goto eof;
 	}
-	sprintf(envstr, "%s=%s", "LOGNAME", pw->pw_name);
-	e->envp = env_set(e->envp, envstr);
 #if defined(BSD)
 	sprintf(envstr, "%s=%s", "USER", pw->pw_name);
-	e->envp = env_set(e->envp, envstr);
+	if ((tenvp = env_set(e->envp, envstr))) {
+		e->envp = tenvp;
+	} else {
+		ecode = e_none;
+		goto eof;
+	}
 #endif
 
 	Debug(DPARS, ("load_entry()...about to parse command\n"))
@@ -292,7 +321,10 @@
 
 	/* got the command in the 'cmd' string; save it in *e.
 	 */
-	e->cmd = strdup(cmd);
+	if ((e->cmd = strdup(cmd)) == NULL) {
+		ecode = e_none;
+		goto eof;
+	}
 
 	Debug(DPARS, ("load_entry()...returning successfully\n"))
 
@@ -301,6 +333,10 @@
 	return e;
 
  eof:
+	if (e->envp)
+		env_free(e->envp);
+	if (e->cmd)
+		free(e->cmd);
 	free(e);
 	if (ecode != e_none && error_func)
 		(*error_func)(ecodes[(int)ecode]);
Index: patched/crontab.c
===================================================================
--- patched.orig/crontab.c	2010-05-06 18:18:24.437560974 +0200
+++ patched/crontab.c	2010-05-06 18:18:27.646435759 +0200
@@ -497,6 +497,10 @@
 	time_t	now = time(NULL);
 	char	**envp = env_init();
 
+	if (envp == NULL) {
+		fprintf(stderr, "%s: Cannot allocate memory.\n", ProgramName);
+		return (-2);
+	}
 	(void) sprintf(n, "tmp.%d", Pid);
 	(void) sprintf(tn, CRON_TAB(n));
 	if (!(tmp = fopen(tn, "w+"))) {
