Subject: Prevent symlink attack
Last-Update: 2010-10-11
Author: Daniel Jacobowitz, Steeve Greenland <stevegr@debian.org>

Prevent symlink attack by ensuring we open a regular file. Also, add some
additional security measures.

IMPORTANT NOTE for Debian: most of this patch will get replaced by a
Debian-specific solution (see features/*).
Index: patched/crontab.c
===================================================================
--- patched.orig/crontab.c	2010-05-06 18:18:39.119435834 +0200
+++ patched/crontab.c	2010-05-06 18:18:39.796561016 +0200
@@ -144,6 +144,7 @@
 	char	*argv[];
 {
 	int		argch;
+	struct stat	statbuf;
 
 	if (!(pw = getpwuid(getuid()))) {
 		fprintf(stderr, "%s: your UID isn't in the passwd file.\n",
@@ -245,6 +246,15 @@
 				perror(Filename);
 				exit(ERROR_EXIT);
 			}
+			/* Make sure we opened a normal file. */
+			if (fstat(fileno(NewCrontab), &statbuf) < 0) {
+				perror("fstat");
+				exit(ERROR_EXIT);
+			}
+			if (!S_ISREG(statbuf.st_mode)) {
+				fprintf(stderr, "%s: Not a regular file.\n", Filename);
+				exit(ERROR_EXIT);
+			}
 			if (swap_uids_back() < OK) {
 				perror("swapping uids back");
 				exit(ERROR_EXIT);
@@ -520,7 +530,14 @@
  done:
 	log_it(RealUser, Pid, "END EDIT", User);
 }
-	
+
+static char tn[MAX_FNAME];
+
+static void sig_handler(int x)
+{
+	unlink(tn);
+	exit(1);
+}	
 
 /* returns	0	on success
  *		-1	on syntax error
@@ -528,23 +545,42 @@
  */
 static int
 replace_cmd() {
-	char	n[MAX_FNAME], envstr[MAX_ENVSTR], tn[MAX_FNAME];
+	char	n[MAX_FNAME], envstr[MAX_ENVSTR];
 	FILE	*tmp;
-	int	ch, eof;
+	int	ch, eof, fd;
 	entry	*e;
 	time_t	now = time(NULL);
 	char	**envp = env_init();
+	mode_t	um;
 
 	if (envp == NULL) {
 		fprintf(stderr, "%s: Cannot allocate memory.\n", ProgramName);
 		return (-2);
 	}
-	(void) snprintf(n, MAX_FNAME, "tmp.%d", Pid);
-	(void) snprintf(tn, MAX_FNAME, CRON_TAB(n));
-	if (!(tmp = fopen(tn, "w+"))) {
-		perror(tn);
+
+
+	/* Assumes Linux-style signal handlers (takes int, returns void) */
+	/* Signal handlers, to ensure we do not leave temp files in the
+	   spool dir.  We don't remove these on exiting this function;
+	   but that's OK, we exit immediately afterwards anyway. */
+	signal(SIGHUP, sig_handler);
+	signal(SIGINT, sig_handler);
+	signal(SIGQUIT, sig_handler);
+	signal(SIGTSTP, SIG_IGN);
+
+	(void) snprintf(tn, MAX_FNAME, CRON_TAB("tmp.XXXXXX"));
+	um = umask(077);
+	fd = mkstemp(tn);
+	if (fd < 0) {
+                fprintf(stderr, "%s/: mkstemp: %s\n", CRONDIR, strerror(errno));
+		return(-2);
+	}
+	tmp = fdopen(fd, "w+");
+	if (!tmp) {
+                fprintf(stderr, "%s/: fdopen: %s\n", CRONDIR, strerror(errno));
 		return (-2);
 	}
+	(void) umask(um);
 
 	/* write a signature at the top of the file.
 	 *
@@ -564,8 +600,8 @@
 	fflush(tmp);  rewind(tmp);
 
 	if (ferror(tmp)) {
-		fprintf(stderr, "%s: %s: %s\n",
-			ProgramName, tn, strerror(errno));
+		fprintf(stderr, "%s: error while writing new crontab to %s\n",
+			ProgramName, tn);
 		fclose(tmp);  unlink(tn);
 		return (-2);
 	}
