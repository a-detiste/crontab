Subject: Properly handle time skips
Last-Update: 2010-04-11

Properly handle time skips, especially those related to Daylight Savings Time.
It should be noted that this fix is not yet considered complete.

http://bugs.debian.org/8499
http://bugs.debian.org/217836
http://bugs.debian.org/458123
http://bugs.debian.org/474157
Index: patched/cron.h
===================================================================
--- patched.orig/cron.h	2010-05-06 18:18:49.631436001 +0200
+++ patched/cron.h	2010-05-06 18:18:51.094436073 +0200
@@ -40,6 +40,13 @@
 #include "config.h"
 #include "externs.h"
 
+#if SYS_TIME_H
+# include <sys/time.h>
+#else
+# include <time.h>
+#endif
+
+
 #ifdef WITH_SELINUX
 #include <selinux/selinux.h>
 #endif
@@ -125,6 +132,10 @@
 			 LineNumber = ln; \
 			}
 
+typedef int time_min;
+
+#define SECONDS_PER_MINUTE 60
+
 #define	FIRST_MINUTE	0
 #define	LAST_MINUTE	59
 #define	MINUTE_COUNT	(LAST_MINUTE - FIRST_MINUTE + 1)
@@ -167,6 +178,8 @@
 #define	DOM_STAR	0x01
 #define	DOW_STAR	0x02
 #define	WHEN_REBOOT	0x04
+#define MIN_STAR	0x08
+#define HR_STAR		0x10
 } entry;
 
 			/* the crontab database will be a list of the
@@ -226,6 +239,8 @@
 		allowed __P((char *)),
 		strdtb __P((char *));
 
+long            get_gmtoff(time_t *, struct tm *);
+
 char		*env_get __P((char *, char **)),
 		*arpadate __P((time_t *)),
 		*mkprints __P((unsigned char *, unsigned int)),
@@ -269,7 +284,11 @@
 
 char	*ProgramName;
 int	LineNumber;
-time_t	TargetTime;
+time_t	StartTime;
+time_min timeRunning;
+time_min virtualTime;
+time_min clockTime;
+static long GMToff;
 
 int     lsbsysinit_mode;
 
@@ -287,7 +306,10 @@
 		*ProgramName;
 extern  int     lsbsysinit_mode;
 extern	int	LineNumber;
-extern	time_t	TargetTime;
+extern	time_t	StartTime;
+extern  time_min timeRunning;
+extern  time_min virtualTime;
+extern  time_min clockTime;
 # if DEBUGGING
 extern	int	DebugFlags;
 extern	char	*DebugFlagNames[];
Index: patched/entry.c
===================================================================
--- patched.orig/entry.c	2010-05-06 18:18:35.745561147 +0200
+++ patched/entry.c	2010-05-06 18:18:51.094436073 +0200
@@ -157,6 +157,7 @@
 			bit_nset(e->dom, 0, (LAST_DOM-FIRST_DOM+1));
 			bit_nset(e->month, 0, (LAST_MONTH-FIRST_MONTH+1));
 			bit_nset(e->dow, 0, (LAST_DOW-FIRST_DOW+1));
+			e->flags |= HR_STAR;
 		} else {
 			ecode = e_timespec;
 			goto eof;
@@ -164,6 +165,8 @@
 	} else {
 		Debug(DPARS, ("load_entry()...about to parse numerics\n"))
 
+		if (ch == '*')
+			e->flags |= MIN_STAR;
 		ch = get_list(e->minute, FIRST_MINUTE, LAST_MINUTE,
 			      PPC_NULL, ch, file);
 		if (ch == EOF) {
@@ -174,6 +177,8 @@
 		/* hours
 		 */
 
+		if (ch == '*')
+			e->flags |= HR_STAR;
 		ch = get_list(e->hour, FIRST_HOUR, LAST_HOUR,
 			      PPC_NULL, ch, file);
 		if (ch == EOF) {
Index: patched/do_command.c
===================================================================
--- patched.orig/do_command.c	2010-05-06 18:18:50.325296679 +0200
+++ patched/do_command.c	2010-05-06 18:18:51.094436073 +0200
@@ -503,7 +503,7 @@
 					e->cmd);
 # if defined(MAIL_DATE)
 				fprintf(mail, "Date: %s\n",
-					arpadate(&TargetTime));
+					arpadate(&StartTime));
 # endif /* MAIL_DATE */
 				for (env = e->envp;  *env;  env++)
 					fprintf(mail, "X-Cron-Env: <%s>\n",
Index: patched/cron.c
===================================================================
--- patched.orig/cron.c	2010-05-06 18:18:49.632435697 +0200
+++ patched/cron.c	2010-05-06 18:18:51.095435790 +0200
@@ -25,20 +25,15 @@
 
 #include "cron.h"
 #include <signal.h>
-#if SYS_TIME_H
-# include <sys/time.h>
-#else
-# include <time.h>
-#endif
 
 #include <sys/types.h>
 #include <fcntl.h>
 
 static	void	usage __P((void)),
 		run_reboot_jobs __P((cron_db *)),
-		cron_tick __P((cron_db *)),
-		cron_sync __P((void)),
-		cron_sleep __P((void)),
+		find_jobs __P((time_min, cron_db *, int, int)),
+		set_time __P((int)),
+		cron_sleep __P((time_min)),
 #ifdef USE_SIGCHLD
 		sigchld_handler __P((int)),
 #endif
@@ -137,23 +132,126 @@
 	database.sysd_mtime = (time_t) 0;
 #endif
 	load_database(&database);
+
+	set_time(TRUE);
 	run_reboot_jobs(&database);
-	cron_sync();
+	timeRunning = virtualTime = clockTime;
+
+	/*
+	 * too many clocks, not enough time (Al. Einstein)
+	 * These clocks are in minutes since the epoch (time()/60).
+	 * virtualTime: is the time it *would* be if we woke up
+	 * promptly and nobody ever changed the clock. It is
+	 * monotonically increasing... unless a timejump happens.
+	 * At the top of the loop, all jobs for 'virtualTime' have run.
+	 * timeRunning: is the time we last awakened.
+	 * clockTime: is the time when set_time was last called.
+	 */
 	while (TRUE) {
-# if DEBUGGING
-		if (!(DebugFlags & DTEST))
-# endif /*DEBUGGING*/
-			cron_sleep();
+		time_min timeDiff;
+		int wakeupKind;
+
+		/* ... wait for the time (in minutes) to change ... */
+		do {
+			cron_sleep(timeRunning + 1);
+			set_time(FALSE);
+		} while (clockTime == timeRunning);
+		timeRunning = clockTime;
 
 		load_database(&database);
 
-		/* do this iteration
+		/*
+		 * ... calculate how the current time differs from
+		 * our virtual clock. Classify the change into one
+		 * of 4 cases
 		 */
-		cron_tick(&database);
+		timeDiff = timeRunning - virtualTime;
 
-		/* sleep 1 minute
-		 */
-		TargetTime += 60;
+		Debug(DSCH, ("[%d] pulse: %d = %d - %d\n",
+            	    getpid(), timeDiff, timeRunning, virtualTime));
+
+		/* shortcut for the most common case */
+		if (timeDiff == 1) {
+			virtualTime = timeRunning;
+			find_jobs(virtualTime, &database, TRUE, TRUE);
+		} else {
+			wakeupKind = -1;
+			if (timeDiff > -(3*MINUTE_COUNT))
+				wakeupKind = 0;
+			if (timeDiff > 0)
+				wakeupKind = 1;
+			if (timeDiff > 5)
+				wakeupKind = 2;
+			if (timeDiff > (3*MINUTE_COUNT))
+				wakeupKind = 3;
+
+			switch (wakeupKind) {
+			case 1:
+				/*
+				 * case 1: timeDiff is a small positive number
+				 * (wokeup late) run jobs for each virtual minute
+				 * until caught up.
+				 */
+				Debug(DSCH, ("[%d], normal case %d minutes to go\n",
+				    getpid(), timeRunning - virtualTime))
+				do {
+					if (job_runqueue())
+						sleep(10);
+					virtualTime++;
+					find_jobs(virtualTime, &database, TRUE, TRUE);
+				} while (virtualTime< timeRunning);
+				break;
+
+			case 2:
+				/*
+				 * case 2: timeDiff is a medium-sized positive number,
+				 * for example because we went to DST run wildcard
+				 * jobs once, then run any fixed-time jobs that would
+				 * otherwise be skipped if we use up our minute
+				 * (possible, if there are a lot of jobs to run) go
+				 * around the loop again so that wildcard jobs have
+				 * a chance to run, and we do our housekeeping
+				 */
+				Debug(DSCH, ("[%d], DST begins %d minutes to go\n",
+				    getpid(), timeRunning - virtualTime))
+				/* run wildcard jobs for current minute */
+				find_jobs(timeRunning, &database, TRUE, FALSE);
+	
+				/* run fixed-time jobs for each minute missed */ 
+				do {
+					if (job_runqueue())
+						sleep(10);
+					virtualTime++;
+					find_jobs(virtualTime, &database, FALSE, TRUE);
+					set_time(FALSE);
+				} while (virtualTime< timeRunning &&
+				    clockTime == timeRunning);
+				break;
+	
+			case 0:
+				/*
+				 * case 3: timeDiff is a small or medium-sized
+				 * negative num, eg. because of DST ending just run
+				 * the wildcard jobs. The fixed-time jobs probably
+				 * have already run, and should not be repeated
+				 * virtual time does not change until we are caught up
+				 */
+				Debug(DSCH, ("[%d], DST ends %d minutes to go\n",
+				    getpid(), virtualTime - timeRunning))
+				find_jobs(timeRunning, &database, TRUE, FALSE);
+				break;
+			default:
+				/*
+				 * other: time has changed a *lot*,
+				 * jump virtual time, and run everything
+				 */
+				Debug(DSCH, ("[%d], clock jumped\n", getpid()))
+				virtualTime = timeRunning;
+				find_jobs(timeRunning, &database, TRUE, TRUE);
+			}
+		}
+		/* jobs to be run (if any) are loaded. clear the queue */
+		job_runqueue();
 	}
 }
 
@@ -177,10 +275,14 @@
 
 
 static void
-cron_tick(db)
+find_jobs(vtime, db, doWild, doNonWild)
+	time_min vtime;
 	cron_db	*db;
+	int doWild;
+	int doNonWild;
 {
- 	register struct tm	*tm = localtime(&TargetTime);
+	time_t   virtualSecond  = vtime * SECONDS_PER_MINUTE;
+	register struct tm 	*tm = gmtime(&virtualSecond);
 	register int		minute, hour, dom, month, dow;
 	register user		*u;
 	register entry		*e;
@@ -193,8 +295,9 @@
 	month = tm->tm_mon +1 /* 0..11 -> 1..12 */ -FIRST_MONTH;
 	dow = tm->tm_wday -FIRST_DOW;
 
-	Debug(DSCH, ("[%d] tick(%d,%d,%d,%d,%d)\n",
-		getpid(), minute, hour, dom, month, dow))
+	Debug(DSCH, ("[%d] tick(%d,%d,%d,%d,%d) %s %s\n",
+		getpid(), minute, hour, dom, month, dow,
+		doWild?" ":"No wildcard",doNonWild?" ":"Wildcard only"))
 
 	/* the dom/dow situation is odd.  '* * 1,15 * Sun' will run on the
 	 * first and fifteenth AND every Sunday;  '* * * * Sun' will run *only*
@@ -205,67 +308,65 @@
 	for (u = db->head;  u != NULL;  u = u->next) {
 		for (e = u->crontab;  e != NULL;  e = e->next) {
 			Debug(DSCH|DEXT, ("user [%s:%d:%d:...] cmd=\"%s\"\n",
-					  env_get("LOGNAME", e->envp),
-					  e->uid, e->gid, e->cmd))
-			if (bit_test(e->minute, minute)
-			 && bit_test(e->hour, hour)
-			 && bit_test(e->month, month)
-			 && ( ((e->flags & DOM_STAR) || (e->flags & DOW_STAR))
+			    env_get("LOGNAME", e->envp),
+			    e->uid, e->gid, e->cmd))
+			if (bit_test(e->minute, minute) &&
+			    bit_test(e->hour, hour) &&
+			    bit_test(e->month, month) &&
+			    ( ((e->flags & DOM_STAR) || (e->flags & DOW_STAR))
 			      ? (bit_test(e->dow,dow) && bit_test(e->dom,dom))
-			      : (bit_test(e->dow,dow) || bit_test(e->dom,dom))
-			    )
-			   ) {
-				job_add(e, u);
+			      : (bit_test(e->dow,dow) || bit_test(e->dom,dom)))) {
+				if ((doNonWild && !(e->flags & (MIN_STAR|HR_STAR)))
+				    || (doWild && (e->flags & (MIN_STAR|HR_STAR))))
+					job_add(e, u);
 			}
 		}
 	}
 }
 
 
-/* the task here is to figure out how long it's going to be until :00 of the
- * following minute and initialize TargetTime to this value.  TargetTime
- * will subsequently slide 60 seconds at a time, with correction applied
- * implicitly in cron_sleep().  it would be nice to let cron execute in
- * the "current minute" before going to sleep, but by restarting cron you
- * could then get it to execute a given minute's jobs more than once.
- * instead we have the chance of missing a minute's jobs completely, but
- * that's something sysadmin's know to expect what with crashing computers..
+/*
+ * Set StartTime and clockTime to the current time.
+ * These are used for computing what time it really is right now.
+ * Note that clockTime is a unix wallclock time converted to minutes.
  */
 static void
-cron_sync() {
- 	register struct tm	*tm;
+set_time(int initialize)
+{
+    struct tm tm;
+    static int isdst;
 
-	TargetTime = time((time_t*)0);
-	tm = localtime(&TargetTime);
-	TargetTime += (60 - tm->tm_sec);
-}
+    StartTime = time(NULL);
 
+    /* We adjust the time to GMT so we can catch DST changes. */
+    tm = *localtime(&StartTime);
+    if (initialize || tm.tm_isdst != isdst) {
+       isdst = tm.tm_isdst;
+       GMToff = get_gmtoff(&StartTime, &tm);
+       Debug(DSCH, ("[%d] GMToff=%ld\n",
+           getpid(), (long)GMToff))
+    }
+    clockTime = (StartTime + GMToff) / (time_t)SECONDS_PER_MINUTE;
+}
 
+/*
+ * try to just hit the next minute
+ */
 static void
-cron_sleep() {
-	register int	seconds_to_wait;
+cron_sleep(target)
+	time_min target;
+{
+	time_t t;
+	int seconds_to_wait;
 
-	do {
-		seconds_to_wait = (int) (TargetTime - time((time_t*)0));
-		Debug(DSCH, ("[%d] TargetTime=%ld, sec-to-wait=%d\n",
-			getpid(), TargetTime, seconds_to_wait))
-
-		/* if we intend to sleep, this means that it's finally
-		 * time to empty the job queue (execute it).
-		 *
-		 * if we run any jobs, we'll probably screw up our timing,
-		 * so go recompute.
-		 *
-		 * note that we depend here on the left-to-right nature
-		 * of &&, and the short-circuiting.
-		 */
-	} while (seconds_to_wait > 0 && job_runqueue());
+	t = time(NULL) + GMToff;
 
-	while (seconds_to_wait > 0) {
-		Debug(DSCH, ("[%d] sleeping for %d seconds\n",
-			getpid(), seconds_to_wait))
-		seconds_to_wait = (int) sleep((unsigned int) seconds_to_wait);
-	}
+	seconds_to_wait = (int)(target * SECONDS_PER_MINUTE - t) + 1;
+	Debug(DSCH, ("[%d] TargetTime=%ld, sec-to-wait=%d\n",
+	    getpid(), (long)target*SECONDS_PER_MINUTE, seconds_to_wait))
+
+        if (seconds_to_wait > 0 && seconds_to_wait < 65)
+            sleep((unsigned int) seconds_to_wait);
 }
 
 
Index: patched/misc.c
===================================================================
--- patched.orig/misc.c	2010-05-06 18:18:50.298436009 +0200
+++ patched/misc.c	2010-05-06 18:18:51.095435790 +0200
@@ -651,8 +651,9 @@
 	struct tm *tm = localtime(&t);
 	char *qmark;
 	size_t len;
-	int hours = tm->tm_gmtoff / 3600;
-	int minutes = (tm->tm_gmtoff - (hours * 3600)) / 60;
+        long gmtoff = get_gmtoff(&t, tm);
+        int hours = gmtoff / 3600;
+        int minutes = (gmtoff - (hours * 3600)) / 60;
 
 	if (minutes < 0)
 		minutes = -minutes;
@@ -682,3 +683,38 @@
 int swap_uids() { return setreuid(geteuid(), getuid()); }
 int swap_uids_back() { return swap_uids(); }
 #endif /*HAVE_SAVED_UIDS*/
+
+
+/* Return the offset from GMT in seconds (algorithm taken from sendmail).
+ *
+ * warning:
+ *	clobbers the static storage space used by localtime() and gmtime().
+ *	If the local pointer is non-NULL it *must* point to a local copy.
+ */
+#ifndef HAVE_TM_GMTOFF
+long get_gmtoff(time_t *clock, struct tm *local)
+{
+	struct tm gmt;
+	long offset;
+
+	gmt = *gmtime(clock);
+	if (local == NULL)
+		local = localtime(clock);
+
+	offset = (local->tm_sec - gmt.tm_sec) +
+	    ((local->tm_min - gmt.tm_min) * 60) +
+	    ((local->tm_hour - gmt.tm_hour) * 3600);
+
+	/* Timezone may cause year rollover to happen on a different day. */
+	if (local->tm_year < gmt.tm_year)
+		offset -= 24 * 3600;
+	else if (local->tm_year > gmt.tm_year)
+		offset += 24 * 3600;
+	else if (local->tm_yday < gmt.tm_yday)
+		offset -= 24 * 3600;
+	else if (local->tm_yday > gmt.tm_yday)
+		offset += 24 * 3600;
+
+	return (offset);
+}
+#endif /* HAVE_TM_GMTOFF */
