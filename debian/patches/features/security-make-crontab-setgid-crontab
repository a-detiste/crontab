Subject: Make crontab SETGID crontab instead of SETUID root
Last-Update: 2010-04-11

This reduces the risk of a security incident in connection with crontab(1).
Nevertheless, Tomi Miettinen's advice in #18333 of not SETing and all but
instead using sockets should be taken into consideration.

Bug-Debian: http://bugs.debian.org/18333
Index: patched/crontab.c
===================================================================
--- patched.orig/crontab.c	2010-05-06 18:18:44.880437493 +0200
+++ patched/crontab.c	2010-05-06 18:18:52.595435667 +0200
@@ -108,7 +108,6 @@
 	setlinebuf(stderr);
 #endif
 	parse_args(argc, argv);		/* sets many globals, opens a file */
-	set_cron_uid();
 	set_cron_cwd();
 	if (!allowed(User)) {
                 if ( getuid() != 0 ) {
@@ -373,12 +372,6 @@
                 return -1;
         }
 
-        if (chown(Directory, getuid(), getgid()) < 0) {
-                perror(Directory);
-                Directory[0] = '\0';
-                return -1;
-        }
-
         /* Now create the actual temporary crontab file */
         if (snprintf(Filename, MAX_FNAME, "%s/crontab", Directory)
             >= MAX_FNAME) {
@@ -414,7 +407,7 @@
 		perror("fstat");
 		return -1;
 	}
-	if (statbuf.st_uid != getuid() || statbuf.st_gid != getgid()) {
+	if (statbuf.st_uid != getuid()) {
 		fprintf(stderr, "Temporary crontab no longer owned by you.\n");
 		return -1;;
 	}
@@ -568,7 +561,6 @@
 		editor = EDITOR;
 	}
 
- again:
 
         /*  Close before cleanup_tmp_crontab is called or otherwise
          *  (on NFS mounted /) will get renamed on unlink */
@@ -577,12 +569,15 @@
                 goto fatal;
 	}
 
+again: /* Loop point for retrying edit after error */
+
 	/* Turn off signals. */
 	(void)signal(SIGHUP, SIG_IGN);
 	(void)signal(SIGINT, SIG_IGN);
 	(void)signal(SIGQUIT, SIG_IGN);
 
-
+        /* Give up privileges while editing */
+        swap_uids();
 
 	switch (pid = fork()) {
 	case -1:
@@ -590,10 +585,14 @@
 		goto fatal;
 	case 0:
 		/* child */
-		if (setuid(getuid()) < 0) {
-			perror("setuid(getuid())");
-			exit(ERROR_EXIT);
-		}
+                if (setgid(getgid()) < 0) {
+                        perror("setgid(getgid())");
+                        exit(ERROR_EXIT);
+                }
+                if (setuid(getuid()) < 0) {
+                        perror("setuid(getuid())");
+                        exit(ERROR_EXIT);
+                }
 		if (chdir("/tmp") < 0) {
 			perror("chdir(/tmp)");
 			exit(ERROR_EXIT);
@@ -643,6 +642,9 @@
 	(void)signal(SIGQUIT, SIG_DFL);
 	(void)signal(SIGTSTP, SIG_DFL);
 
+        /* Need privs again */
+        swap_uids_back();
+
         switch (open_tmp_crontab(&fsbuf)) {
         case -1:
                 fprintf(stderr, "Error while editing crontab\n");
@@ -725,21 +727,12 @@
 	time_t	now = time(NULL);
 	char	**envp = env_init();
 	mode_t	um;
-	int	saved_uid;
 
 	if (envp == NULL) {
 		fprintf(stderr, "%s: Cannot allocate memory.\n", ProgramName);
 		return (-2);
 	}
 
-	/* Assume privilege.  This way we can only receive signals on our
-	   input - the ones listed below (or from root - root's problem, not
-	   ours). */
-	saved_uid = getuid();
-	if (setuid(geteuid()) < 0) {
-		perror("setuid");
-		return -2;
-	}
 
 	/* Assumes Linux-style signal handlers (takes int, returns void) */
 	/* Signal handlers, to ensure we do not leave temp files in the
@@ -813,22 +806,9 @@
 	if (CheckErrorCount != 0) {
 		fprintf(stderr, "errors in crontab file, can't install.\n");
 		fclose(tmp);  unlink(tn);
-		/* Give up privilege, in case we loop. */
-		if (setreuid(saved_uid, -1) < 0)
-			return (-2);
 		return (-1);
 	}
 
-#ifdef HAS_FCHOWN
-	if (fchown(fileno(tmp), ROOT_UID, -1) < OK)
-#else
-	if (chown(tn, ROOT_UID, -1) < OK)
-#endif
-	{
-		perror("chown");
-		fclose(tmp);  unlink(tn);
-		return (-2);
-	}
 
 #ifdef HAS_FCHMOD
 	if (fchmod(fileno(tmp), 0600) < OK)
@@ -848,6 +828,15 @@
 		return (-2);
 	}
 
+        /* Root on behalf of another user must set file owner to that user */
+        if (getuid() == ROOT_UID && strcmp(User, RealUser) != 0) {
+            if (chown(tn, pw->pw_uid, -1) != 0) {
+                perror("chown");
+                unlink(tn);
+                return -2;
+            }
+        }
+
 	(void) snprintf(n, sizeof(n), CRON_TAB(User));
 	if (rename(tn, n)) {
 		fprintf(stderr, "%s: %s: rename: %s\n",
@@ -861,11 +850,6 @@
 
 	poke_daemon();
 
-	/* Give up privilege, just in case. */
-	/* Don't need to check for error; nothing happens beyond here but a log entry,
-	   and the failure message is incorrect after the rename above. */
-	setreuid(saved_uid, -1);
-
 	return (0);
 }
 
Index: patched/database.c
===================================================================
--- patched.orig/database.c	2010-05-06 18:18:49.631436001 +0200
+++ patched/database.c	2010-05-06 18:18:52.595435667 +0200
@@ -24,7 +24,9 @@
 
 
 #include "cron.h"
+#define __USE_GNU /* For O_NOFOLLOW */
 #include <fcntl.h>
+#undef __USE_GNU
 #include <sys/stat.h>
 #include <sys/file.h>
 
@@ -337,18 +339,77 @@
 		goto next_crontab;
 	}
 
-	if ((crontab_fd = open(tabname, O_RDONLY, 0)) < OK) {
+        if (pw) {
+            /* Path for user crontabs (including root's!) */
+            if ((crontab_fd = open(tabname, O_RDONLY|O_NOFOLLOW, 0)) < OK) {
 		/* crontab not accessible?
 		 */
 		log_it(fname, getpid(), "CAN'T OPEN", tabname);
 		goto next_crontab;
-	}
+            }
 
-	if (fstat(crontab_fd, statbuf) < OK) {
+            if (fstat(crontab_fd, statbuf) < OK) {
 		log_it(fname, getpid(), "FSTAT FAILED", tabname);
 		goto next_crontab;
-	}
+            }
+            /* Check to make sure that the crontab is owned by the correct user
+               (or root) */
+
+            if (statbuf->st_uid != pw->pw_uid &&
+                statbuf->st_uid != ROOT_UID) {
+                log_it(fname, getpid(), "WRONG FILE OWNER", tabname);
+		goto next_crontab;
+            }
+            if (!S_ISREG(statbuf->st_mode) ||
+                statbuf->st_nlink != 1 ||
+                (statbuf->st_mode & 07777) != 0600) {
+                log_it(fname, getpid(), "WRONG INODE INFO", tabname);
+ 		goto next_crontab;
+            }
+        } else {
+            /* System crontab path. These can be symlinks, but the
+               symlink and the target must be owned by root. */
+            if (lstat(tabname, statbuf) < OK) {
+		log_it(fname, getpid(), "LSTAT FAILED", tabname);
+		goto next_crontab;
+            }
+            if (S_ISLNK(statbuf->st_mode) && statbuf->st_uid != ROOT_UID) {
+                log_it(fname, getpid(), "WRONG SYMLINK OWNER", tabname);
+		goto next_crontab;
+            }
+            if ((crontab_fd = open(tabname, O_RDONLY, 0)) < OK) {
+		/* crontab not accessible?
+		 */
+		log_it(fname, getpid(), "CAN'T OPEN", tabname);
+		goto next_crontab;
+            }
 
+            if (fstat(crontab_fd, statbuf) < OK) {
+		log_it(fname, getpid(), "FSTAT FAILED", tabname);
+		goto next_crontab;
+            }
+            /* Check to make sure that the crontab is owned by root */
+            if (statbuf->st_uid != ROOT_UID) {
+                log_it(fname, getpid(), "WRONG FILE OWNER", tabname);
+		goto next_crontab;
+            }
+            /* Check to make sure that the crontab is writable only by root */
+            if ((statbuf->st_mode & S_IWGRP) || (statbuf->st_mode & S_IWOTH))  {
+                log_it(fname, getpid(), "WRONG INODE INFO", tabname);
+		goto next_crontab;
+            }
+            /* Technically, we should also check whether the parent dir is
+ 	     * writable, and so on. This would only make proper sense for
+ 	     * regular files; we can't realistically check all possible
+ 	     * security issues resulting from symlinks. We'll just assume that
+ 	     * root will handle responsible when creating them.
+	     */
+        }
+        /*
+         * The link count check is not sufficient (the owner may
+         * delete their original link, reducing the link count back to
+         * 1), but this is all we've got.
+         */
 	Debug(DLOAD, ("\t%s:", fname))
 	u = find_user(old_db, fname);
 	if (u != NULL) {
Index: patched/misc.c
===================================================================
--- patched.orig/misc.c	2010-05-06 18:18:51.875560985 +0200
+++ patched/misc.c	2010-05-06 18:18:52.595435667 +0200
@@ -35,6 +35,7 @@
 #include <errno.h>
 #include <string.h>
 #include <fcntl.h>
+#include <grp.h>
 #if defined(SYSLOG)
 # include <syslog.h>
 #endif
@@ -191,18 +192,29 @@
 set_cron_cwd()
 {
 	struct stat	sb;
-
+	mode_t		um;
+	struct group	*gr;
+	
 	/* first check for CRONDIR ("/var/cron" or some such)
 	 */
 	if (stat(CRONDIR, &sb) < OK && errno == ENOENT) {
 		perror(CRONDIR);
-		if (OK == mkdir(CRONDIR, 0700)) {
+
+		/* crontab(1) running SGID crontab shouldn't attempt to create
+		 * directories */
+		if (getuid() != 0 )
+			exit(ERROR_EXIT);
+
+		um = umask(000);
+		if (OK == mkdir(CRONDIR, CRONDIR_MODE)) {
 			fprintf(stderr, "%s: created\n", CRONDIR);
 			stat(CRONDIR, &sb);
 		} else {
-			fprintf(stderr, "%s: mkdir: %s\n", CRONDIR, strerror(errno));
+			fprintf(stderr, "%s: mkdir: %s\n", CRONDIR,
+				strerror(errno));
 			exit(ERROR_EXIT);
 		}
+		(void) umask(um);
 	}
 	if (!(sb.st_mode & S_IFDIR)) {
 		fprintf(stderr, "'%s' is not a directory, bailing out.\n",
@@ -218,11 +230,33 @@
 	 */
 	if (stat(SPOOL_DIR, &sb) < OK && errno == ENOENT) {
 		perror(SPOOL_DIR);
-		if (OK == mkdir(SPOOL_DIR, 0700)) {
+
+		/* crontab(1) running SGID crontab shouldn't attempt to create
+		 * directories */
+		if (getuid() != 0 )
+			exit(ERROR_EXIT);
+
+		um = umask(000);
+		if (OK == mkdir(SPOOL_DIR, SPOOL_DIR_MODE)) {
 			fprintf(stderr, "%s: created\n", SPOOL_DIR);
-			stat(SPOOL_DIR, &sb);
 		} else {
-			fprintf(stderr, "%s: mkdir: %s\n", SPOOL_DIR, strerror(errno));
+			fprintf(stderr, "%s: mkdir: %s\n", SPOOL_DIR,
+				strerror(errno));
+			exit(ERROR_EXIT);
+		}
+		(void) umask(um);
+
+		if (!(gr = getgrnam(SPOOL_DIR_GROUP))) {
+			fprintf(stderr, "%s: getgrnam: %s\n", SPOOL_DIR,
+				strerror(errno));
+			exit(ERROR_EXIT);
+		}
+		if (OK == chown(SPOOL_DIR, -1, gr->gr_gid)) {
+			fprintf(stderr, "%s: chowned\n", SPOOL_DIR);
+				stat(SPOOL_DIR, &sb);
+		} else {
+			fprintf(stderr, "%s: chown: %s\n", SPOOL_DIR,
+			strerror(errno));
 			exit(ERROR_EXIT);
 		}
 	}
Index: patched/pathnames.h
===================================================================
--- patched.orig/pathnames.h	2010-05-06 18:18:50.298436009 +0200
+++ patched/pathnames.h	2010-05-06 18:18:52.595435667 +0200
@@ -93,3 +93,25 @@
 #ifndef _PATH_DEFPATH_ROOT
 # define _PATH_DEFPATH_ROOT "/usr/sbin:/usr/bin:/sbin:/bin"
 #endif
+
+
+#ifdef DEBIAN
+#ifndef CRONDIR_MODE
+			/* Create mode for CRONDIR; must be in sync with
+			 * packaging
+			 */
+#define CRONDIR_MODE 0755
+#endif
+#ifndef SPOOL_DIR_MODE
+			/* Create mode for SPOOL_DIR; must be in sync with
+			 * packaging
+			 */
+#define SPOOL_DIR_MODE 01730
+#endif
+#ifndef SPOOL_DIR_GROUP
+			/* Chown SPOOL_DIR to this group (needed by Debian's
+			 * SGID crontab feature)
+			 */ 
+#define SPOOL_DIR_GROUP "crontab"
+#endif
+#endif
